---
description: 
globs: 
alwaysApply: true
---
# INFINA PFA - CODING & COMPONENT RULES (Updated 2025)

## üéØ CORE PRINCIPLES

### SOLID PRINCIPLES (Mandatory)

- **Single Responsibility**: Each component/function/hook has ONE clear purpose
- **Open/Closed**: Components should be open for extension, closed for modification
- **Liskov Substitution**: Components should be replaceable with their subtypes
- **Interface Segregation**: Create focused, specific interfaces
- **Dependency Inversion**: Depend on abstractions (services), not implementations (direct API calls)

## üèóÔ∏è ARCHITECTURE LAYERS (New)

### API Service Layer (Mandatory)

- **No direct fetch() calls in hooks/components**
- **All API calls must go through service layer**
- **Centralized error handling and response transformation**

```typescript
// ‚úÖ Good - Service layer pattern
const budgetService = {
  async getAll(): Promise<Budget[]> {
    return apiClient.get<Budget[]>('/budgets');
  },
  async create(data: CreateBudgetRequest): Promise<Budget> {
    return apiClient.post<Budget>('/budgets', data);
  }
};

// ‚ùå Bad - Direct API calls in hooks
const useBudgets = () => {
  const response = await fetch('/api/budgets'); // Forbidden!
};
```

### Error Handling Strategy (Mandatory)

- **Centralized error codes and messages**
- **Consistent error transformation across the app**
- **User-friendly error messages only**

```typescript
// ‚úÖ Good - Centralized error handling
import { handleError } from '@/lib/error-handler';

const createBudget = async (data) => {
  try {
    return await budgetService.create(data);
  } catch (error) {
    const appError = handleError(error);
    setError(appError.message);
    return null;
  }
};

// ‚ùå Bad - Inconsistent error handling
} catch (error) {
  const errorMessage = error instanceof Error ? error.message : "An error occurred";
  setError(errorMessage);
}
```

## üåç INTERNATIONALIZATION & TRANSLATIONS (Mandatory)

### Translation Requirements

- **NEVER hardcode text in components** - All user-facing text must use translations
- **All text must support Vietnamese and English** - Current supported languages
- **Use react-i18next** for translation management
- **Organize translations by page/section** for better maintainability

```typescript
// ‚úÖ Good - Using translations
import { useAppTranslation } from "@/hooks/use-translation";

const WelcomeMessage = () => {
  const { t } = useAppTranslation(["namespace","common"]);
  
  return (
    <div>
      <h1>{t("welcome")}</h1>
      <p>{t("getStartedMessage", {ns: "namespace"})}</p>
      <button>{t("getStarted")}</button>
    </div>
  );
};

// ‚ùå Bad - Hardcoded text
const WelcomeMessage = () => {
  return (
    <div>
      <h1>Welcome</h1>
      <p>Get started with your financial journey</p>
      <button>Get Started</button>
    </div>
  );
};
```

### Translation File Organization

- **Organize translations by section**: `common.ts`, `auth.ts`, `hero.ts`, etc.
- **Use descriptive keys**: `heroMainTitle`, `authSignInButton`, `budgetCreateSuccess`
- **Maintain consistency** across language files
- **Keep translations in sync** - every key must exist in all language files

```typescript
// ‚úÖ Good - Well-organized translation structure
export const authEn = {
  // Sign In
  signInTitle: "Sign in to your account",
  signInButton: "Sign In",
  signInSuccess: "Successfully signed in",
  
  // Sign Up
  signUpTitle: "Create your account",
  signUpButton: "Sign Up",
  signUpSuccess: "Account created successfully",
  
  // Validation
  emailRequired: "Email is required",
  passwordRequired: "Password is required",
};

// ‚ùå Bad - Unclear or missing organization
export const authEn = {
  title: "Sign in", // Too generic
  btn: "Go", // Unclear abbreviation
  msg: "OK", // Too vague
};
```

### Translation Best Practices

- **Dynamic content**: Use interpolation for dynamic values
- **Pluralization**: Handle singular/plural forms properly
- **Context**: Provide context in key names for better understanding
- **Error messages**: Always translate error messages
- **Accessibility**: Translate alt texts, aria-labels, and screen reader content

```typescript
// ‚úÖ Good - Dynamic translations with interpolation
const { t } = useAppTranslation();

const BudgetSummary = ({ amount, budgetName }: { amount: number; budgetName: string }) => {
  return (
    <div>
      <h2>{t("budgetSummaryTitle", { name: budgetName })}</h2>
      <p>{t("budgetRemainingAmount", { amount: formatCurrency(amount) })}</p>
      <p>{t("expenseCount", { count: expenses.length })}</p>
    </div>
  );
};

// Translation files should include interpolation:
export const budgetEn = {
  budgetSummaryTitle: "{{name}} Budget Summary",
  budgetRemainingAmount: "Remaining: {{amount}}",
  expenseCount_one: "{{count}} expense",
  expenseCount_other: "{{count}} expenses",
};

// ‚ùå Bad - Hardcoded dynamic content
const BudgetSummary = ({ amount, budgetName }) => {
  return (
    <div>
      <h2>{budgetName} Budget Summary</h2>
      <p>Remaining: {formatCurrency(amount)}</p>
    </div>
  );
};
```

## üì¶ COMPONENT ARCHITECTURE

### Component Size & Structure

- **Max 200 lines per component file** (strictly enforced)
- **One component per file** (no exceptions)
- **Separate logic from UI** when component becomes complex (>100 lines)
- **Extract custom hooks for complex state logic**
- **Use composition over inheritance**
- **Split large components into feature-specific components**

```typescript
// ‚úÖ Good - Component composition
const DashboardPage = () => (
  <div>
    <DashboardHeader />
    <DashboardStats />
    <DashboardContent />
  </div>
);

// ‚ùå Bad - Monolithic component (180+ lines)
const DashboardPage = () => {
  // 180+ lines of mixed logic and UI
};
```

## ü™ù HOOKS & STATE MANAGEMENT (Updated)

### Single Responsibility Hooks (Mandatory)

- **One hook = One responsibility**
- **No monolithic hooks** (like the old useBudgets with 271 lines)
- **Compose hooks when multiple operations needed**

```typescript
// ‚úÖ Good - Single responsibility hooks
const useBudgetList = () => { /* Only manages list */ };
const useBudgetCreate = () => { /* Only handles creation */ };
const useBudgetUpdate = () => { /* Only handles updates */ };
const useBudgetDelete = () => { /* Only handles deletion */ };

// Composition when needed
const useBudgetManagement = () => {
  const list = useBudgetList();
  const create = useBudgetCreate();
  const update = useBudgetUpdate();
  const delete = useBudgetDelete();
  
  return { list, create, update, delete };
};

// ‚ùå Bad - Monolithic hook
const useBudgets = () => {
  // 271 lines handling everything
};
```

### Custom Hooks Rules

- **Prefix with 'use'**: `useBudgetList`, `useBudgetCreate`
- **Single responsibility** per hook
- **Return objects for multiple values**: `{ data, loading, error }`
- **Proper cleanup** in useEffect
- **Memoization** when appropriate (useMemo, useCallback)

### State Management Patterns

```typescript
// ‚úÖ Good - Simple state for focused hooks
const useBudgetCreate = () => {
  const [isCreating, setIsCreating] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const createBudget = async (data: CreateBudgetRequest) => {
    try {
      setIsCreating(true);
      setError(null);
      return await budgetService.create(data);
    } catch (error) {
      const appError = handleError(error);
      setError(appError.message);
      return null;
    } finally {
      setIsCreating(false);
    }
  };

  return { createBudget, isCreating, error };
};

// ‚úÖ Good - useReducer for complex state
const useBudgetList = () => {
  const [state, dispatch] = useReducer(budgetReducer, initialState);
  // ...
};
```

## üìÅ FILE STRUCTURE & IMPORTS (Updated)

### File Naming

- **Components**: `user-profile.tsx`, `payment-form.tsx`
- **Hooks**: `use-budget-list.ts`, `use-budget-create.ts`
- **Services**: `budget.service.ts`, `auth.service.ts`
- **Utils**: `format-currency.ts`, `validate-email.ts`
- **Types**: `budget.types.ts`, `auth.types.ts`
- **Errors**: `errors.ts`, `error-handler.ts`

### Directory Structure
