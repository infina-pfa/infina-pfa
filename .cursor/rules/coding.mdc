---
description: 
globs: 
alwaysApply: true
---
# INFINA PFA - CODING & COMPONENT RULES (Updated 2025)

## üéØ CORE PRINCIPLES

### SOLID PRINCIPLES (Mandatory)

- **Single Responsibility**: Each component/function/hook has ONE clear purpose
- **Open/Closed**: Components should be open for extension, closed for modification
- **Liskov Substitution**: Components should be replaceable with their subtypes
- **Interface Segregation**: Create focused, specific interfaces
- **Dependency Inversion**: Depend on abstractions (services), not implementations (direct API calls)

## üèóÔ∏è ARCHITECTURE LAYERS (New)

### API Service Layer (Mandatory)

- **No direct fetch() calls in hooks/components**
- **All API calls must go through service layer**
- **Centralized error handling and response transformation**

```typescript
// ‚úÖ Good - Service layer pattern
const budgetService = {
  async getAll(): Promise<Budget[]> {
    return apiClient.get<Budget[]>('/budgets');
  },
  async create(data: CreateBudgetRequest): Promise<Budget> {
    return apiClient.post<Budget>('/budgets', data);
  }
};

// ‚ùå Bad - Direct API calls in hooks
const useBudgets = () => {
  const response = await fetch('/api/budgets'); // Forbidden!
};
```

### Error Handling Strategy (Mandatory)

- **Centralized error codes and messages**
- **Consistent error transformation across the app**
- **User-friendly error messages only**

```typescript
// ‚úÖ Good - Centralized error handling
import { handleError } from '@/lib/error-handler';

const createBudget = async (data) => {
  try {
    return await budgetService.create(data);
  } catch (error) {
    const appError = handleError(error);
    setError(appError.message);
    return null;
  }
};

// ‚ùå Bad - Inconsistent error handling
} catch (error) {
  const errorMessage = error instanceof Error ? error.message : "An error occurred";
  setError(errorMessage);
}
```

## üì¶ COMPONENT ARCHITECTURE

### Component Size & Structure

- **Max 200 lines per component file** (strictly enforced)
- **One component per file** (no exceptions)
- **Separate logic from UI** when component becomes complex (>100 lines)
- **Extract custom hooks for complex state logic**
- **Use composition over inheritance**
- **Split large components into feature-specific components**

```typescript
// ‚úÖ Good - Component composition
const DashboardPage = () => (
  <div>
    <DashboardHeader />
    <DashboardStats />
    <DashboardContent />
  </div>
);

// ‚ùå Bad - Monolithic component (180+ lines)
const DashboardPage = () => {
  // 180+ lines of mixed logic and UI
};
```

## ü™ù HOOKS & STATE MANAGEMENT (Updated)

### Single Responsibility Hooks (Mandatory)

- **One hook = One responsibility**
- **No monolithic hooks** (like the old useBudgets with 271 lines)
- **Compose hooks when multiple operations needed**

```typescript
// ‚úÖ Good - Single responsibility hooks
const useBudgetList = () => { /* Only manages list */ };
const useBudgetCreate = () => { /* Only handles creation */ };
const useBudgetUpdate = () => { /* Only handles updates */ };
const useBudgetDelete = () => { /* Only handles deletion */ };

// Composition when needed
const useBudgetManagement = () => {
  const list = useBudgetList();
  const create = useBudgetCreate();
  const update = useBudgetUpdate();
  const delete = useBudgetDelete();
  
  return { list, create, update, delete };
};

// ‚ùå Bad - Monolithic hook
const useBudgets = () => {
  // 271 lines handling everything
};
```

### Custom Hooks Rules

- **Prefix with 'use'**: `useBudgetList`, `useBudgetCreate`
- **Single responsibility** per hook
- **Return objects for multiple values**: `{ data, loading, error }`
- **Proper cleanup** in useEffect
- **Memoization** when appropriate (useMemo, useCallback)

### State Management Patterns

```typescript
// ‚úÖ Good - Simple state for focused hooks
const useBudgetCreate = () => {
  const [isCreating, setIsCreating] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const createBudget = async (data: CreateBudgetRequest) => {
    try {
      setIsCreating(true);
      setError(null);
      return await budgetService.create(data);
    } catch (error) {
      const appError = handleError(error);
      setError(appError.message);
      return null;
    } finally {
      setIsCreating(false);
    }
  };

  return { createBudget, isCreating, error };
};

// ‚úÖ Good - useReducer for complex state
const useBudgetList = () => {
  const [state, dispatch] = useReducer(budgetReducer, initialState);
  // ...
};
```

## üìÅ FILE STRUCTURE & IMPORTS (Updated)

### File Naming

- **Components**: `user-profile.tsx`, `payment-form.tsx`
- **Hooks**: `use-budget-list.ts`, `use-budget-create.ts`
- **Services**: `budget.service.ts`, `auth.service.ts`
- **Utils**: `format-currency.ts`, `validate-email.ts`
- **Types**: `budget.types.ts`, `auth.types.ts`
- **Errors**: `errors.ts`, `error-handler.ts`

### Directory Structure
